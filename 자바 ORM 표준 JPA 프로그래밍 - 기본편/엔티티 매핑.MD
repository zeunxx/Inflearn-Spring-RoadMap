## 엔티티 매핑

<br>

### 엔티티 매핑 종류
1. 객체와 테이블 매핑 : @Entity, @Table
2. 필드와 컬럼 매핑 : @Column
3. 기본키 매핑 : @Id
4. 연관관계 매핑 : @ManyToOne, @JoinColumn

<br>

## 객체와 테이블 매핑

### 1️⃣ @Entity
: @Entity가 붙은 클래스는 JPA가 관리, 엔티티라 함
- JPA를 사용해서 테이블과 매핑할 클래스는 @Entity 필수

📌 주의
- 기본 생성자 필수(파라미터가 없는 public 또는 protected 생성자) 
- final 클래스, enum, interface, inner 클래스에 사용X 
- 저장할 필드에 final 사용 X


#### 💁 @Entity 속성 정리
- 속성 : name
    - JPA에서 사용할 엔티티 이름 지정
    - 기본값: 클래스 이름을 그대로 사용
    - 같은 클래스 이름이 없으면 가급적 기본값 사용

<BR>

### 2️⃣ @Table
: @Table은 엔티티와 매핑할 테이블 지정

<img width="389" alt="image" src="https://user-images.githubusercontent.com/81572478/212542158-232737bc-601f-4940-91e3-4dfad2138407.png">

<br>

### 📌 데이터베이스 스키마 자동 생성

➡️ JPA는 애플리케이션 로딩 시점에 DB 테이블 생성 기능 지원 (로컬 PC 개발 단계때 도움 됨)

- DDL을 애플리케이션 실행 시점에 자동 생성
- 테이블 중심 -> 객체 중심
- 데이터베이스 방언을 활용해서 데이터베이스에 맞는 적절한 DDL 생성
- 이렇게 생성된 **DDL은 개발 장비에서만 사용!!**
- 생성된 DDL은 운영서버에는 사용하지 않거나, 적절히 다듬은 후 사용

➕ DDL: 데이터베이스를 정의하는 언어, 데이터를 생성/수정/삭제 등 데이터의 전체 골격을 결정하는 역할의 언어

<BR>

<img width="397" alt="image" src="https://user-images.githubusercontent.com/81572478/212542409-5fbdcefa-73b9-43f1-ad97-7021e59a0495.png">


📌 ***운영 장비에는 절대 create, create-drop, update 사용하면
안된다.***

- 개발 초기 단계는 create 또는 update 
- 테스트 서버는 update 또는 validate 
- 스테이징과 운영 서버는 validate 또는 none


### DDL 생성 기능
- 제약 조건 추가: EX) 회원이름은 필수, 10자 초과X

    @Column(nullable = false, length = 10)

    - 데이터베이스에 영향을 주고, 애플리케이션 런타임에는 영향 x


➡️ DDL 생성 기능은 DDL을 자동 생성할 때만 사용되고
JPA의 실행 로직에는 영향을 주지 않는다!

<br><Br>

## 필드와 컬럼 매핑

<br>
➕ 요구사항 추가
1. 회원은 일반 회원과 관리자로 구분해야 한다. 
2. 회원 가입일과 수정일이 있어야 한다. 
3. 회원을 설명할 수 있는 필드가 있어야 한다. 이 필드는 길이 제
한이 없다.

<br>

```
package org.example;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import javax.persistence.*;
import java.util.Date;

@Entity
@Getter
@Setter
public class Member {
    @Id
    private Long id;
    
    @Column(name = "name")
    private String username; // 객체는 username으로 쓰고, DB 컬럼명 name을 씀
    
    private Integer age;
    
    @Enumerated(EnumType.STRING)
    private RoleType roleType; // 객체는 ENUM 타입을 쓰고, DB는 ENUM이 없어서 @Enumerated 어노테이션 써야 함
    
    @Temporal(TemporalType.TIMESTAMP)
    private Date createdDate; // 날짜 타입을 맞추기 위해? TIMESTAMP
    
    @Temporal(TemporalType.TIMESTAMP)
    private Date lastModifiedDate;
    
    @Lob
    private String description; // DB에 큰 string을 넣고 싶을때 @Lob 사용

    //Getter, Setter… 
} 


```

```
create table Member (
       id bigint not null,
        age integer,
        createdDate timestamp,
        description clob,
        lastModifiedDate timestamp,
        roleType varchar(255),
        name varchar(255),
        primary key (id)
    )
```
➡️ 이렇게 자동 생성 됨


### 매핑 어노테이션 정리

<img width="374" alt="image" src="https://user-images.githubusercontent.com/81572478/212543592-a7ee1aa1-8846-4879-8069-8f0262d87788.png">

- @Transient : 특정 필드는 db와 관계없이 메모리에서만 다루고 싶을때

### 1. @Column

<img width="453" alt="image" src="https://user-images.githubusercontent.com/81572478/212543715-db2f367d-5fc3-4291-b061-8f525c7ea561.png">

- unique 제약조건은 @Table에서 조건 거는 것이 좋음
    - @Table(uniqueConstraints = {@UniqueConstraint( name = "NAME_AGE_UNIQUE",
 columnNames = {"NAME", "AGE"} )})

 <br>

### 2. @Enumerated
 : 자바 enum 타입을 매핑할때 사용 (ORDINAL 대신 STRING 타입 사용!!)

 <img width="420" alt="image" src="https://user-images.githubusercontent.com/81572478/212544003-b3305c70-98fd-4334-9ffc-db15ede2372b.png">

<BR>

### 3. @Temporal 
- 날짜 타입(java.util.Date, java.util.Calendar)을 매핑할 때 사용
- 참고: LocalDate, LocalDateTime을 사용할 때는 생략 가능(최신 하이버네이트 지원) 

<br>

### 4. @Lob

- 데이터베이스 BLOB, CLOB 타입과 매핑 
- @Lob에는 지정할 수 있는 속성이 없다. 
- 매핑하는 필드 타입이 문자면 CLOB 매핑, 나머지는 BLOB 매핑
    - CLOB: String, char[], java.sql.CLOB 
    - BLOB: byte[], java.sql. BLOB
